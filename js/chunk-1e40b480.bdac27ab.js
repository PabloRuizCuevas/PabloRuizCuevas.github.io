(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-1e40b480"],{"2b22":function(e,t,a){"use strict";a("f2f4")},"89e1":function(e,t,a){e.exports=a.p+"img/RF_shapes.473ab1c4.png"},"8be2":function(e,t,a){e.exports=a.p+"img/Mc.0f3df03a.png"},d030:function(e,t,a){"use strict";a.r(t);var n=a("7a23"),o=a("8be2"),i=a.n(o),r=a("89e1"),s=a.n(r),c=Object(n["E"])("data-v-1a86c03e");Object(n["t"])("data-v-1a86c03e");var l={class:"page"},h=Object(n["g"])("main",null,[Object(n["g"])("div",{class:"article"},[Object(n["g"])("h1",null," Monte Carlo Reduction Factor"),Object(n["g"])("p",null," A Monte Carlo appromimation can gives us a general approach to calculate the reduction factor whenever no analytical solution is possible. First of all we need to know the difference of path length given of two parallel beams with respect to the optical axis, this is already calculated in the literature {Reference} and is given by: $$\\Delta L_2= x - \\frac{x*cos({\\theta_D}) + y * sin{(\\theta_D)}}{cos{(2 \\theta - \\theta_D )}} $$ Where X and Y are the components of the vector r denoting the distance of an arbitrary scattering point to the center of the sample. These leads to a phase difference at the detector given by: $$\\Delta \\Phi_D = 2 \\pi \\frac{\\Delta L_2 }{ \\Lambda} $$ And where \\( \\Lambda \\) is the distance traveled by a neutron of velocity v over one period of the oscillating signal. So the general equation for the reduction factor will be the integral over the \\( cos(\\Delta \\psi_D) \\) over all possible neutron sample interaction points. $$ R_{sample} = \\frac{ \\int{ cos( { \\Delta\\psi_D} ) dV }}{V} $$ This integral, is has not always an analytical solution but is easy to calculate by a standard MC algorithm. First of all we will need a evenly distributed cluster of 3D random points inside our sample shape. And then we will average over all the $cos( { \\Delta\\psi_D} )$ of the random points. So we end up having the next equation: $$ R_{sample} = \\lim_{N\\to\\infty} \\frac{1}{N}\\sum_{ i = 0 }^{N} cos( { \\Delta\\psi_D})_i $$ The last thing we need to do is ensure that our approach gives the same result in the cases that we have an analytical formula. "),Object(n["g"])("div",{class:"image_container"},[Object(n["g"])("img",{alt:"Figure",src:i.a}),Object(n["g"])("figcaption",null," MC simulations with different number of iterations vs the real analytic value, The shape chosen for this simulation it was a cylinder.")]),Object(n["g"])("p",null," The error of MC decays with the square root of the random points used, but as the reduction factor is often zero, the relative error is not a good measure of the precision of this method, in any case for most applications we have estimated that 1e5 are enough iterations to have a reasonably good convergence. Finally we can calculate the reduction factor for different shapes and compare it with the theory "),Object(n["g"])("div",{class:"image_container"},[Object(n["g"])("img",{alt:"Figure",src:s.a}),Object(n["g"])("figcaption",null," Reduction factor for different shapes and comparation with theory. ")])])],-1);Object(n["r"])();var d=c((function(e,t,a,o,i,r){return Object(n["q"])(),Object(n["d"])("div",l,[h])})),u={name:"Latexpage3",data:function(){return{latex:"$$\\frac{a}{b}$$"}},methods:{reRender:function(){window.MathJax&&(console.log("rendering mathjax"),window.MathJax.Hub.Queue(["Typeset",window.MathJax.Hub],(function(){return console.log("done")})))}},mounted:function(){this.reRender()},watch:{latex:function(){var e=this;console.log("data changed"),this.$nextTick().then((function(){e.reRender()}))}}};a("2b22");u.render=d,u.__scopeId="data-v-1a86c03e";t["default"]=u},f2f4:function(e,t,a){}}]);
//# sourceMappingURL=chunk-1e40b480.bdac27ab.js.map